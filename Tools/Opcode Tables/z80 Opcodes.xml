<?xml version="1.0" encoding="UTF-8" ?>
<!--
-->

<OpcodeData xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="./Opcodes.xsd">
  <Opcode Value='00' Function='NOP' Group='General' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>NOP</Mnemonic>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>------</Flags>
      <Description>The CPU performs no operation during this machine cycle</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='01' Function='LOAD' Group='16-Bit Load' Length='3'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='WordReg'>WordReg</Arg>
        <Arg encoding='WordImmidate'>Word</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(10)</Cycles>
      <Flags>------</Flags>
      <Description>The 2-byte integer nn is loaded to the dd register pair</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='02' Function='LOAD' Group='8-Bit Load' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='WordReg'>WordRegPtr-BD</Arg>
        <Arg encoding='Direct'>ByteReg-A</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of the Accumulator are loaded to the memory location specified by the contents of the register pair.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='03' Function='INC' Group='16-Bit Arithmetic' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>INC</Mnemonic>
      <Arguments>
        <Arg encoding='WordReg'>WordReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(6)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of register pair ss (any of register pairs BC, DE, HL, or SP) are incremented.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='04' Function='INC' Group='8-Bit Arithmetic' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>INC</Mnemonic>
      <Arguments>
        <Arg encoding='Dest'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>SZHP0-</Flags>
      <Description>Register r is incremented</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='05' Function='DEC' Group='8-Bit Arithmetic' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>DEC</Mnemonic>
      <Arguments>
        <Arg encoding='Dest'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The byte specified by the m operand is decremented</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='06' Function='LOAD' Group='8-Bit Load' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='Dest'>ByteReg</Arg>
        <Arg encoding='ByteImmidate'>Byte</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>------</Flags>
      <Description>The 8-bit integer n is loaded to any register r.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='07' Function='RL' Group='Logical' Length='1'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>RLCA</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>--0-0C</Flags>
      <Description>The contents of the Accumulator (register A) are rotated left 1-bit position. The sign bit (bit 7) is copied to the Carry flag and also to bit 0. Bit 0 is the least-significant bit.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>RLC</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>--0-0C</Flags>
      <Description>The contents of the Accumulator (register A) are rotated left 1-bit position. The sign bit (bit 7) is copied to the Carry flag and also to bit 0. Bit 0 is the least-significant bit.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='08' Function='EX' Group='16-Bit Load' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>EX</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordReg-AF</Arg>
        <Arg encoding='Direct'>WordReg-AFAlt</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>------</Flags>
      <Description>The 2-byte contents of the register pairs AF and AF' are exchanged.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='09' Function='ADD' Group='16-Bit Arithmetic' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>ADD</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordReg-HL</Arg>
        <Arg encoding='WordReg'>WordReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>3(11)</Cycles>
      <Flags>--H-0C</Flags>
      <Description>The contents of register pair ss (any of register pairs BC, DE, HL, or SP) are added to the contents of register pair HL and the result is stored in HL</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='0A' Function='LOAD' Group='8-Bit Load' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='WordReg'>WordRegPtr-BD</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of the memory location specified by the contents of the rr register pair are loaded to the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='0B' Function='DEC' Group='16-Bit Arithmetic' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>DEC</Mnemonic>
      <Arguments>
        <Arg encoding='WordReg'>WordReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(6)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of register pair ss (any of the register pairs BC, DE, HL, or SP) are decremented.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='0F' Function='RR' Group='Logical' Length='1'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>RRCA</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>--0-0C</Flags>
      <Description>The contents of the Accumulator (register A) are rotated right 1-bit position. Bit 0 is copied to the Carry flag and also to bit 7. Bit 0 is the least- significant bit.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='0F' Function='RR-CY' Group='Logical' Length='1'>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>RRC</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>--0-0C</Flags>
      <Description>The contents of the Accumulator (register A) are rotated right 1-bit position. Bit 0 is copied to the Carry flag and also to bit 7. Bit 0 is the least- significant bit.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='10' Function='DJNZ' Group='Branch' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>DJNZ</Mnemonic>
      <Arguments>
        <Arg encoding='ByteImmidate'>Displacment</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>3(13)</Cycles>
      <Flags>------</Flags>
      <Description>This instruction is similar to the conditional jump instructions except that a register value is used to determine branching. The B register is decremented, and if a non zero value remains, the value of the displacement e is added to the Program Counter (PC). The next instruction is fetched from the location designated by the new contents of the PC. The jump is measured from the address of the instruction Op Code and has a range of -126 to +129 bytes. The assembler automatically adjusts for the twice incremented PC.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='17' Function='RL-CY' Group='Logical' Length='1'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>RLA</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>--0-0C</Flags>
      <Description>The contents of the Accumulator (register A) are rotated left 1-bit position through the Carry flag. The previous content of the Carry flag is copied to bit 0. Bit 0 is the least-significant bit.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>RL</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>--0-0C</Flags>
      <Description>The contents of the Accumulator (register A) are rotated left 1-bit position through the Carry flag. The previous content of the Carry flag is copied to bit 0. Bit 0 is the least-significant bit.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='18' Function='JMPR' Group='Branch' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>JR</Mnemonic>
      <Arguments>
        <Arg encoding='ByteImmidate'>Displacment</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>3(12)</Cycles>
      <Flags>------</Flags>
      <Description>This instruction provides for unconditional branching to other segments of a program. The value of the displacement e is added to the Program Counter (PC) and the next instruction is fetched from the location designated by the new contents of the PC. This jump is measured from the address of the instruction Op Code and has a range of-126 to +129 bytes. The assembler automatically adjusts for the twice incremented PC.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='1F' Function='RR-CY' Group='Logical' Length='1'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>RRA</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>--0-0C</Flags>
      <Description>The contents of the Accumulator (register A) are rotated right 1-bit position through the Carry flag. The previous content of the Carry flag is copied to bit 7. Bit 0 is the least-significant bit.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='1F' Function='RR' Group='Logical' Length='1'>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>RR</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>--0-0C</Flags>
      <Description>The contents of the Accumulator (register A) are rotated right 1-bit position through the Carry flag. The previous content of the Carry flag is copied to bit 7. Bit 0 is the least-significant bit.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='20' Function='JMPR' Group='Branch' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>JR</Mnemonic>
      <Arguments>
        <Arg encoding='HalfFlag'>HalfFlag</Arg>
        <Arg encoding='ByteImmidate'>Displacment</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>3(12)</Cycles>
      <Flags>------</Flags>
      <Description>This instruction provides for conditional branching to other segments of a program depending on the results of a test on the Carry Flag. If the flag is equal to a 1, the value of the displacement e is added to the Program Counter (PC) and the next instruction is fetched from the location designated by the new contents of the PC. The jump is measured from the address of the instruction Op Code and has a range of -126 to +129 bytes. The assembler automatically adjusts for the twice incremented PC</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='22' Function='LOAD' Group='16-Bit Load' Length='3'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='WordImmidate'>AddressPtr</Arg>
        <Arg encoding='Direct'>WordReg-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(16)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of the low order portion of register pair HL (register L) are loaded to memory address (nn), and the contents of the high order portion of HL (register H) are loaded to the next highest memory address (nn+1). The first n operand after the Op Code is the low order byte of nn</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='27' Function='BCD_ADJUST' Group='8-Bit Arithmetic' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>DAA</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>SZHP-C</Flags>
      <Description>This instruction conditionally adjusts the Accumulator for BCD addition and subtraction operations</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='2A' Function='LOAD' Group='16-Bit Load' Length='3'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordReg-HL</Arg>
        <Arg encoding='WordImmidate'>AddressPtr</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(16)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of memory address (nn) are loaded to the low order portion of register pair HL (register L), and the contents of the next highest memory address (nn+1) are loaded to the high order portion of HL (register H). The first n operand after the Op Code is the low order byte of nn.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='2F' Function='NOT' Group='Logical' Length='1'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>CPL</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>--1-1-</Flags>
      <Description>The contents of the Accumulator (register A) are inverted (one’s complement).</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>CPL</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>--1-1-</Flags>
      <Description>The contents of the Accumulator (register A) are inverted (one’s complement).</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='32' Function='LOAD' Group='8-Bit Load' Length='3'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='WordImmidate'>AddressPtr</Arg>
        <Arg encoding='Direct'>ByteReg-A</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>4(13)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of the Accumulator are loaded to the memory address specified by the operand nn. The first n operand after the Op Code is the low order byte of nn.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='34' Function='INC' Group='8-Bit Arithmetic' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>INC</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>3(11)</Cycles>
      <Flags>SZHP0-</Flags>
      <Description>The byte contained in the address specified by the contents of the HL register pair is incremented.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='35' Function='DEC' Group='8-Bit Arithmetic' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>DEC</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>3(11)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The byte specified by the m operand is decremented</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='36' Function='LOAD' Group='8-Bit Load' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
        <Arg encoding='ByteImmidate'>Byte</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>3(10)</Cycles>
      <Flags>------</Flags>
      <Description>Integer n is loaded to the memory address specified by the contents of the HL register pair.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='37' Function='CY_SET' Group='Logical' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>SCF</Mnemonic>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>--0-01</Flags>
      <Description>The Carry flag in the F register is set.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='3A' Function='LOAD' Group='8-Bit Load' Length='3'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='WordImmidate'>AddressPtr</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>4(13)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of the memory location specified by the operands nn are loaded to the Accumulator. The first n operand after the Op Code is the low order byte of a 2-byte memory address.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='3F' Function='CY_INVERT' Group='Logical' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>CCF</Mnemonic>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>-----C</Flags>
      <Description>The Carry flag in the F register is inverted.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='40' Function='LOAD' Group='8-Bit Load' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='Dest'>ByteReg</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of any register r' are loaded to any other register r.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='46' Function='LOAD' Group='8-Bit Load' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='Dest'>ByteReg</Arg>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>------</Flags>
      <Description>The 8-bit contents of memory location (HL) are loaded to register r</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='70' Function='LOAD' Group='8-Bit Load' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of register r are loaded to the memory location specified by the contents of the HL register pair.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='76' Function='HALT' Group='General' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>HALT</Mnemonic>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>------</Flags>
      <Description>The HALT instruction suspends CPU operation until a subsequent interruptor reset is received. While in the HALT state, the processor executes NOPs to maintain memory refresh logic</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='80' Function='ADD' Group='8-Bit Arithmetic' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>ADD</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>SZHP0C</Flags>
      <Description>The contents of register r are added to the contents of the Accumulator, and the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='86' Function='ADD' Group='8-Bit Arithmetic' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>ADD</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>SZHP0C</Flags>
      <Description>The byte at the memory address specified by the contents of the HL register pair is added to the contents of the Accumulator, and the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='88' Function='ADD-CY' Group='8-Bit Arithmetic' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>ADC</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>SZHP0C</Flags>
      <Description>The s operand, along with the Carry Flag (C in the F register) is added to the contents of the Accumulator, and the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='8E' Function='ADD-CY' Group='8-Bit Arithmetic' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>ADC</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>SZHP0C</Flags>
      <Description>The s operand, along with the Carry Flag (C in the F register) is added to the contents of the Accumulator, and the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='90' Function='SUB' Group='8-Bit Arithmetic' Length='1'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>SUB</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>SZ0P1C</Flags>
      <Description>The s operand is subtracted from the contents of the Accumulator, and the result is stored in the Accumulator.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>SUB</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>SZ0P1C</Flags>
      <Description>The s operand is subtracted from the contents of the Accumulator, and the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='96' Function='SUB' Group='8-Bit Arithmetic' Length='1'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>SUB</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>SZ0P1C</Flags>
      <Description>The s operand is subtracted from the contents of the Accumulator, and the result is stored in the Accumulator.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>SUB</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>SZ0P1C</Flags>
      <Description>The s operand is subtracted from the contents of the Accumulator, and the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='98' Function='SUB-CY' Group='8-Bit Arithmetic' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>SBC</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>SZ0P1C</Flags>
      <Description>The s operand, along with the Carry flag (C in the F register) is subtracted from the contents of the Accumulator, and the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='9E' Function='SUB-CY' Group='8-Bit Arithmetic' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>SBC</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>SZ0P1C</Flags>
      <Description>The s operand, along with the Carry flag (C in the F register) is subtracted from the contents of the Accumulator, and the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='A0' Function='AND' Group='Logical' Length='1'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>AND</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>SZ1P00</Flags>
      <Description>A logical AND operation is performed between the byte specified by the s operand and the byte contained in the Accumulator; the result is stored in the Accumulator</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>AND</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>SZ1P00</Flags>
      <Description>A logical AND operation is performed between the byte specified by the s operand and the byte contained in the Accumulator; the result is stored in the Accumulator</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='A6' Function='AND' Group='Logical' Length='1'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>AND</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>SZ1P00</Flags>
      <Description>A logical AND operation is performed between the byte specified by the s operand and the byte contained in the Accumulator; the result is stored in the Accumulator</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>AND</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>SZ1P00</Flags>
      <Description>A logical AND operation is performed between the byte specified by the s operand and the byte contained in the Accumulator; the result is stored in the Accumulator</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='A8' Function='XOR' Group='Logical' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>XOR</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>SZ0P00</Flags>
      <Description>The logical exclusive-OR operation is performed between the byte specified by the s operand and the byte contained in the Accumulator; the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='AE' Function='XOR' Group='Logical' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>XOR</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>SZ0P00</Flags>
      <Description>The logical exclusive-OR operation is performed between the byte specified by the s operand and the byte contained in the Accumulator; the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='B0' Function='OR' Group='Logical' Length='1'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>OR</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>SZ0P00</Flags>
      <Description>A logical OR operation is performed between the byte specified by the s operand and the byte contained in the Accumulator; the result is stored in the Accumulator.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>OR</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>SZ0P00</Flags>
      <Description>A logical OR operation is performed between the byte specified by the s operand and the byte contained in the Accumulator; the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='B6' Function='OR' Group='Logical' Length='1'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>OR</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>SZ0P00</Flags>
      <Description>A logical OR operation is performed between the byte specified by the s operand and the byte contained in the Accumulator; the result is stored in the Accumulator.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>OR</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>SZ0P00</Flags>
      <Description>A logical OR operation is performed between the byte specified by the s operand and the byte contained in the Accumulator; the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='B8' Function='CMP' Group='Logical' Length='1'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>CP</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The contents of the s operand are compared with the contents of the Accumulator. If there is a true compare, the Z flag is set. The execution of this instruction does not affect the contents of the Accumulator.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>CP</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The contents of the s operand are compared with the contents of the Accumulator. If there is a true compare, the Z flag is set. The execution of this instruction does not affect the contents of the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='BE' Function='CMP' Group='Logical' Length='1'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>CP</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The contents of the s operand are compared with the contents of the Accumulator. If there is a true compare, the Z flag is set. The execution of this instruction does not affect the contents of the Accumulator.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>CP</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The contents of the s operand are compared with the contents of the Accumulator. If there is a true compare, the Z flag is set. The execution of this instruction does not affect the contents of the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='C0' Function='RET' Group='Branch' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>RET</Mnemonic>
      <Arguments>
        <Arg encoding='Flag'>Flag</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>3(11)</Cycles>
      <Flags>------</Flags>
      <Description>If condition cc is true, the byte at the memory location specified by the contents of the Stack Pointer (SP) register pair is moved to the low order eight bits of the Program Counter (PC). The SP is incremented and the byte at the memory location specified by the new contents of the SP are moved to the high order eight bits of the PC. The SP is incremented again. The next Op Code following this instruction is fetched from the memory location specified by the PC</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='C1' Function='POP' Group='Stack' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>POP</Mnemonic>
      <Arguments>
        <Arg encoding='WordReg'>WordReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>3(10)</Cycles>
      <Flags>------</Flags>
      <Description>The top two bytes of the external memory LIFO (last-in, first-out) Stack are popped to register pair qq.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='C2' Function='JMP' Group='Branch' Length='3'>
    <Encoding Platform='z80'>
      <Mnemonic>JP</Mnemonic>
      <Arguments>
        <Arg encoding='Flag'>Flag</Arg>
        <Arg encoding='WordImmidate'>Address</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>3(10)</Cycles>
      <Flags>------</Flags>
      <Description>If condition cc is true, the instruction loads operand nn to register pair PC (Program Counter), and the program continues with the instruction beginning at address nn. If condition cc is false, the Program Counter is incremented as usual, and the program continues with the next sequential instruction.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='C3' Function='JMP' Group='Branch' Length='3'>
    <Encoding Platform='z80'>
      <Mnemonic>JP</Mnemonic>
      <Arguments>
        <Arg encoding='WordImmidate'>Address</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>3(10)</Cycles>
      <Flags>------</Flags>
      <Description>Operand nn is loaded to register pair PC (Program Counter). The next instruction is fetched from the location designated by the new contents of the PC.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='C4' Function='CALL' Group='Branch' Length='3'>
    <Encoding Platform='z80'>
      <Mnemonic>CALL</Mnemonic>
      <Arguments>
        <Arg encoding='Flag'>Flag</Arg>
        <Arg encoding='WordImmidate'>Address</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(17)</Cycles>
      <Flags>------</Flags>
      <Description>If condition cc is true, this instruction pushes the current contents of the Program Counter (PC) onto the top of the external memory stack, then loads the operands nn to PC to point to the address in memory where the first Op Code of a subroutine is to be fetched. </Description>
    </Encoding>
  </Opcode>
  <Opcode Value='C5' Function='PUSH' Group='Stack' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>PUSH</Mnemonic>
      <Arguments>
        <Arg encoding='WordReg'>WordReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>3(11)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of the register pair qq are pushed to the external memory LIFO (last-in, first-out) Stack. The Stack Pointer (SP) register pair holds the 16-bit address of the current top of the Stack.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='C6' Function='ADD' Group='8-Bit Arithmetic' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>ADD</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='ByteImmidate'>Byte</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>SZHP0C</Flags>
      <Description>The integer n is added to the contents of the Accumulator, and the results are stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='C7' Function='RST' Group='Branch' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>RST</Mnemonic>
      <Arguments>
        <Arg encoding='Dest'>RstValue</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>3(11)</Cycles>
      <Flags>------</Flags>
      <Description>The current Program Counter (PC) contents are pushed onto the external memory stack, and the page zero memory location given by operand p is loaded to the PC. Program execution then begins with the Op Code in the address now pointed to by PC. The push is performed by first decrementing the contents of the Stack Pointer (SP), loading the high-order byte of PC to the memory address now pointed to by SP, decrementing SP again, and loading the low order byte of PC to the address now pointed to by SP. TheRestart instruction allows for a jump to one of eight addresses indicated in the table below.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='C9' Function='RET' Group='Branch' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>RET</Mnemonic>
      <Status>Documented</Status>
      <Cycles>3(10)</Cycles>
      <Flags>------</Flags>
      <Description>The byte at the memory location specified by the contents of the Stack Pointer (SP) register pair is moved to the low order eight bits of the Program Counter (PC). The SP is now incremented and the byte at the memory location specified by the new contents of this instruction is fetched from the memory location specified by the PC.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='CB' Function='PREFIX' Group='Prefix' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>[None]</Mnemonic>
      <Status>Documented</Status>
      <Cycles>0</Cycles>
      <Flags>------</Flags>
      <Description>Bit Instruction Prefix</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='CD' Function='CALL' Group='Branch' Length='3'>
    <Encoding Platform='z80'>
      <Mnemonic>CALL</Mnemonic>
      <Arguments>
        <Arg encoding='WordImmidate'>Address</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(17)</Cycles>
      <Flags>------</Flags>
      <Description>The current contents of the Program Counter (PC) are pushed onto the top of the external memory stack. The operands nn are then loaded to the PC to point to the address in memory where the first Op Code of a subroutine is to be fetched. </Description>
    </Encoding>
  </Opcode>
  <Opcode Value='CE' Function='ADD-CY' Group='8-Bit Arithmetic' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>ADC</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='ByteImmidate'>Byte</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>SZHP0C</Flags>
      <Description>The s operand, along with the Carry Flag (C in the F register) is added to the contents of the Accumulator, and the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='D3' Function='OUT' Group='I/O' Length='2'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>OUT</Mnemonic>
      <Arguments>
        <Arg encoding='ByteImmidate'>BytePtr</Arg>
        <Arg encoding='Direct'>ByteReg-A</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>3(11)</Cycles>
      <Flags>------</Flags>
      <Description>The operand n is placed on the bottom half (A0 through A7) of the address bus to select the I/O device at one of 256 possible ports. The contents of the Accumulator (register A) also appear on the top half (A8 through A15) of the address bus at this time. Then the byte contained in the Accumulator is placed on the data bus and written to the selected peripheral device</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>OUT</Mnemonic>
      <Arguments>
        <Arg encoding='ByteImmidate'>Byte</Arg>
        <Arg encoding='Direct'>ByteReg-A</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>3(11)</Cycles>
      <Flags>------</Flags>
      <Description>The operand n is placed on the bottom half (A0 through A7) of the address bus to select the I/O device at one of 256 possible ports. The contents of the Accumulator (register A) also appear on the top half (A8 through A15) of the address bus at this time. Then the byte contained in the Accumulator is placed on the data bus and written to the selected peripheral device</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='D6' Function='SUB' Group='8-Bit Arithmetic' Length='2'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>SUB</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='ByteImmidate'>Byte</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>SZ0P1C</Flags>
      <Description>The s operand is subtracted from the contents of the Accumulator, and the result is stored in the Accumulator.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>SUB</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
        <Arg encoding='ByteImmidate'>Byte</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>SZ0P1C</Flags>
      <Description>The s operand is subtracted from the contents of the Accumulator, and the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='D9' Function='EXX' Group='16-Bit Load' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>EXX</Mnemonic>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>------</Flags>
      <Description>Each 2-byte value in register pairs BC, DE, and HL is exchanged with the 2-byte value in BC', DE', and HL', respectively.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='DB' Function='IN' Group='I/O' Length='2'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>IN</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='ByteImmidate'>BytePtr</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>3(11)</Cycles>
      <Flags>------</Flags>
      <Description>The operand n is placed on the bottom half (A0 through A7) of the address bus to select the I/O device at one of 256 possible ports. The contents of the Accumulator also appear on the top half (A8 through A15) of the address bus at this time. Then one byte from the selected port is placed on the data bus and written to the Accumulator (register A) in the CPU.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>IN</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='ByteImmidate'>Byte</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>3(11)</Cycles>
      <Flags>------</Flags>
      <Description>The operand n is placed on the bottom half (A0 through A7) of the address bus to select the I/O device at one of 256 possible ports. The contents of the Accumulator also appear on the top half (A8 through A15) of the address bus at this time. Then one byte from the selected port is placed on the data bus and written to the Accumulator (register A) in the CPU.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='DD' Function='PREFIX' Group='Prefix' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>[None]</Mnemonic>
      <Status>Documented</Status>
      <Cycles>0</Cycles>
      <Flags>------</Flags>
      <Description>IX Prefix</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='DE' Function='SUB-CY' Group='8-Bit Arithmetic' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>SBC</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='ByteImmidate'>Byte</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>SZ0P1C</Flags>
      <Description>The s operand, along with the Carry flag (C in the F register) is subtracted from the contents of the Accumulator, and the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='E3' Function='EX' Group='16-Bit Load' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>EX</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordRegPtr-SP</Arg>
        <Arg encoding='Direct'>WordReg-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(19)</Cycles>
      <Flags>------</Flags>
      <Description>The low order byte contained in register pair HL is exchanged with the contents of the memory address specified by the contents of register pair SP (Stack Pointer), and the high order byte of HL is exchanged with the next highest memory address (SP+1).</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='E6' Function='AND' Group='Logical' Length='2'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>AND</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='ByteImmidate'>Byte</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>SZ1P00</Flags>
      <Description>A logical AND operation is performed between the byte specified by the s operand and the byte contained in the Accumulator; the result is stored in the Accumulator</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>AND</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
        <Arg encoding='ByteImmidate'>Byte</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>SZ1P00</Flags>
      <Description>A logical AND operation is performed between the byte specified by the s operand and the byte contained in the Accumulator; the result is stored in the Accumulator</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='E9' Function='JMP' Group='Branch' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>JP</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordReg-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>------</Flags>
      <Description>The Program Counter (register pair PC) is loaded with the contents of the HL register pair. The next instruction is fetched from the location designated by the new contents of the PC</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='EB' Function='EX' Group='16-Bit Load' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>EX</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordReg-DE</Arg>
        <Arg encoding='Direct'>WordReg-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>------</Flags>
      <Description>The 2-byte contents of register pairs DE and HL are exchanged.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='ED' Function='PREFIX' Group='Prefix' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>[None]</Mnemonic>
      <Status>Documented</Status>
      <Cycles>0</Cycles>
      <Flags>------</Flags>
      <Description>Extended Instruction Prefix</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='EE' Function='XOR' Group='Logical' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>XOR</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='ByteImmidate'>Byte</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>SZ0P00</Flags>
      <Description>The logical exclusive-OR operation is performed between the byte specified by the s operand and the byte contained in the Accumulator; the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='F1' Function='POP' Group='Stack' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>POP</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordReg-AF</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>3(10)</Cycles>
      <Flags>SZHPNC</Flags>
      <Description>The top two bytes of the external memory LIFO (last-in, first-out) Stack are popped to register pair qq.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='F3' Function='DI' Group='Interrupt' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>DI</Mnemonic>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>------</Flags>
      <Description>DI disables the maskable interrupt by resetting the interrupt enable flip- flops (IFF1 and IFF2). Note that this instruction disables the maskable interrupt during its execution</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='F5' Function='PUSH' Group='Stack' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>PUSH</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordReg-AF</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>3(11)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of the register pair qq are pushed to the external memory LIFO (last-in, first-out) Stack. The Stack Pointer (SP) register pair holds the 16-bit address of the current top of the Stack.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='F6' Function='OR' Group='Logical' Length='2'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>OR</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='ByteImmidate'>Byte</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>SZ0P00</Flags>
      <Description>A logical OR operation is performed between the byte specified by the s operand and the byte contained in the Accumulator; the result is stored in the Accumulator.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>OR</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
        <Arg encoding='ByteImmidate'>Byte</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>SZ0P00</Flags>
      <Description>A logical OR operation is performed between the byte specified by the s operand and the byte contained in the Accumulator; the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='F9' Function='LOAD' Group='16-Bit Load' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordReg-SP</Arg>
        <Arg encoding='Direct'>WordReg-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>1(6)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of the register pair HL are loaded to the Stack Pointer (SP).</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='FB' Function='EI' Group='Interrupt' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>EI</Mnemonic>
      <Status>Documented</Status>
      <Cycles>1(4)</Cycles>
      <Flags>------</Flags>
      <Description>The enable interrupt instruction sets both interrupt enable flip flops (IFFI and IFF2) to a logic 1, allowing recognition of any maskable interrupt. Note that during the execution of this instruction and the following instruction, maskable interrupts are disabled.</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='FD' Function='PREFIX' Group='Prefix' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>[None]</Mnemonic>
      <Status>Documented</Status>
      <Cycles>0</Cycles>
      <Flags>------</Flags>
      <Description>IY Prefix</Description>
    </Encoding>
  </Opcode>
  <Opcode Value='FE' Function='CMP' Group='Logical' Length='2'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>CP</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='ByteImmidate'>Byte</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The contents of the s operand are compared with the contents of the Accumulator. If there is a true compare, the Z flag is set. The execution of this instruction does not affect the contents of the Accumulator.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>CP</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
        <Arg encoding='ByteImmidate'>Byte</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(7)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The contents of the s operand are compared with the contents of the Accumulator. If there is a true compare, the Z flag is set. The execution of this instruction does not affect the contents of the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='CB' Value='00' Function='RL' Group='Logical' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>RLC</Mnemonic>
      <Arguments>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>The contents of register r are rotated left 1-bit position. The content of bit 7 is copied to the Carry flag and also to bit 0.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='CB' Value='06' Function='RL' Group='Logical' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>RLC</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>4(15)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>The contents of the memory address specified by the contents of register pair HL are rotated left 1-bit position. The content of bit 7 is copied to the Carry flag and also to bit 0. Bit 0 is the least-significant bit.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='CB' Value='08' Function='RR' Group='Logical' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>RRC</Mnemonic>
      <Arguments>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>The contents of the m operand are rotated right 1-bit position. The content of bit 0 is copied to the Carry flag and also to bit 7. Bit 0 is the least- significant bit.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='CB' Value='0E' Function='RR' Group='Logical' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>RRC</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>4(15)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>The contents of the m operand are rotated right 1-bit position. The content of bit 0 is copied to the Carry flag and also to bit 7. Bit 0 is the least- significant bit.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='CB' Value='10' Function='RL-CY' Group='Logical' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>RL</Mnemonic>
      <Arguments>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>8(4)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>The contents of the m operand are rotated left 1-bit position. The content of bit 7 is copied to the Carry flag and the previous content of the Carry flag is copied to bit 0.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='CB' Value='16' Function='RL-CY' Group='Logical' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>RL</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>The contents of the m operand are rotated left 1-bit position. The content of bit 7 is copied to the Carry flag and the previous content of the Carry flag is copied to bit 0.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='CB' Value='18' Function='RR-CY' Group='Logical' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>RR</Mnemonic>
      <Arguments>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>8(4)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>The contents of operand m are rotated right 1-bit position through the Carry flag. The content of bit 0 is copied to the Carry flag and the previous content of the Carry flag is copied to bit 7. Bit 0 is the least-significant bit.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='CB' Value='1E' Function='RR-CY' Group='Logical' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>RR</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>4(15)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>The contents of operand m are rotated right 1-bit position through the Carry flag. The content of bit 0 is copied to the Carry flag and the previous content of the Carry flag is copied to bit 7. Bit 0 is the least-significant bit.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='CB' Value='20' Function='SL-Signed' Group='Logical' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>SLA</Mnemonic>
      <Arguments>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>An arithmetic shift left 1-bit position is performed on the contents of operand m. The content of bit 7 is copied to the Carry flag. Bit 0 is the least-significant bit.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='CB' Value='26' Function='SL-Signed' Group='Logical' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>SLA</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>4(15)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>An arithmetic shift left 1-bit position is performed on the contents of operand m. The content of bit 7 is copied to the Carry flag. Bit 0 is the least-significant bit.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='CB' Value='28' Function='SR-Signed' Group='Logical' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>SRA</Mnemonic>
      <Arguments>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(4)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>An arithmetic shift right 1-bit position is performed on the contents of operand m. The content of bit 0 is copied to the Carry flag and the previous content of bit 7 is unchanged. Bit 0 is the least-significant bit.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='CB' Value='2E' Function='SR-Signed' Group='Logical' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>SRA</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>4(15)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>An arithmetic shift right 1-bit position is performed on the contents of operand m. The content of bit 0 is copied to the Carry flag and the previous content of bit 7 is unchanged. Bit 0 is the least-significant bit.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='CB' Value='30' Function='SL-L' Group='Logical' Length='2'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>SL1</Mnemonic>
      <Arguments>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>An arithmetic shift left 1-bit position is performed on the contents of operand m. The content of bit 7 is copied to the Carry flag. Bit 0 is set. Bit 0 is the least-significant bit.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>SLL</Mnemonic>
      <Arguments>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>An arithmetic shift left 1-bit position is performed on the contents of operand m. The content of bit 7 is copied to the Carry flag. Bit 0 is set. Bit 0 is the least-significant bit.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='CB' Value='36' Function='SL-L' Group='Logical' Length='2'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>SL1</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>4(15)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>An arithmetic shift left 1-bit position is performed on the contents of operand m. The content of bit 7 is copied to the Carry flag. Bit 0 is set. Bit 0 is the least-significant bit.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>SLL</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>4(15)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>An arithmetic shift left 1-bit position is performed on the contents of operand m. The content of bit 7 is copied to the Carry flag. Bit 0 is set. Bit 0 is the least-significant bit.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='CB' Value='38' Function='SR-L' Group='Logical' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>SRL</Mnemonic>
      <Arguments>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>0Z0P0C</Flags>
      <Description>The contents of operand m are shifted right 1-bit position. The content of bit 0 is copied to the Carry flag, and bit 7 is reset. Bit 0 is the least- significant bit.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='CB' Value='3E' Function='SR-L' Group='Logical' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>SRL</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>4(15)</Cycles>
      <Flags>0Z0P0C</Flags>
      <Description>The contents of operand m are shifted right 1-bit position. The content of bit 0 is copied to the Carry flag, and bit 7 is reset. Bit 0 is the least- significant bit.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='CB' Value='40' Function='BIT' Group='Bit' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>BIT</Mnemonic>
      <Arguments>
        <Arg encoding='Dest'>Value</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>?Z1?0-</Flags>
      <Description>This instruction tests bit b in register r and sets the Z flag accordingly</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='CB' Value='46' Function='BIT' Group='Bit' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>BIT</Mnemonic>
      <Arguments>
        <Arg encoding='Dest'>Value</Arg>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>3(12)</Cycles>
      <Flags>?Z1?0-</Flags>
      <Description>This instruction tests bit b in the memory location specified by the contents of the HL register pair and sets the Z flag accordingly.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='CB' Value='80' Function='RES' Group='Bit' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>RES</Mnemonic>
      <Arguments>
        <Arg encoding='Dest'>Value</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>4(8)</Cycles>
      <Flags>------</Flags>
      <Description>Bit b in operand m is reset</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='CB' Value='86' Function='RES' Group='Bit' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>RES</Mnemonic>
      <Arguments>
        <Arg encoding='Dest'>Value</Arg>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>4(15)</Cycles>
      <Flags>------</Flags>
      <Description>Bit b in operand m is reset</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='CB' Value='C0' Function='SET' Group='Bit' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>SET</Mnemonic>
      <Arguments>
        <Arg encoding='Dest'>Value</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>------</Flags>
      <Description>Bit b in register r (any of registers B, C, D, E, H, L, or A) is set.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='CB' Value='C6' Function='SET' Group='Bit' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>SET</Mnemonic>
      <Arguments>
        <Arg encoding='Dest'>Value</Arg>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>4(15)</Cycles>
      <Flags>------</Flags>
      <Description>Bit b in the memory location addressed by the contents of register pair HL is set.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='40' Function='IN' Group='I/O' Length='2'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>IN</Mnemonic>
      <Arguments>
        <Arg encoding='Dest'>ByteReg</Arg>
        <Arg encoding='Direct'>ByteRegPtr-C</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>3(12)</Cycles>
      <Flags>SZ0P0-</Flags>
      <Description>The contents of register C are placed on the bottom half (A0 through A7) of the address bus to select the I/O device at one of 256 possible ports. The contents of Register B are placed on the top half (A8 through A15) of the address bus at this time. Then one byte from the selected port is placed on the data bus and written to register r in the CPU.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>IN</Mnemonic>
      <Arguments>
        <Arg encoding='Dest'>ByteReg</Arg>
        <Arg encoding='Direct'>ByteReg-C</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>3(12)</Cycles>
      <Flags>SZ0P0-</Flags>
      <Description>The contents of register C are placed on the bottom half (A0 through A7) of the address bus to select the I/O device at one of 256 possible ports. The contents of Register B are placed on the top half (A8 through A15) of the address bus at this time. Then one byte from the selected port is placed on the data bus and written to register r in the CPU.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='41' Function='OUT' Group='I/O' Length='2'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>OUT</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteRegPtr-C</Arg>
        <Arg encoding='Dest'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>3(12)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of register C are placed on the bottom half (A0 through A7) of the address bus to select the I/O device at one of 256 possible ports. The contents of Register B are placed on the top half (A8 through A15) of the address bus at this time. Then the byte contained in register r is placed on the data bus and written to the selected peripheral device.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>OUT</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-C</Arg>
        <Arg encoding='Dest'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>3(12)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of register C are placed on the bottom half (A0 through A7) of the address bus to select the I/O device at one of 256 possible ports. The contents of Register B are placed on the top half (A8 through A15) of the address bus at this time. Then the byte contained in register r is placed on the data bus and written to the selected peripheral device.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='42' Function='SUB-CY' Group='16-Bit Arithmetic' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>SBC</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordReg-HL</Arg>
        <Arg encoding='WordReg'>WordReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>4(15)</Cycles>
      <Flags>SZ0P1C</Flags>
      <Description>The contents of the register pair ss (any of register pairs BC, DE, HL, or SP) and the Carry Flag (C flag in the F register) are subtracted from the contents of register pair HL, and the result is stored in HL.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='43' Function='LOAD' Group='16-Bit Load' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='WordImmidate'>AddressPtr</Arg>
        <Arg encoding='WordReg'>WordReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>6(20)</Cycles>
      <Flags>------</Flags>
      <Description>The low order byte of register pair dd is loaded to memory address (nn); the upper byte is loaded to memory address (nn+1).</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='44' Function='NEG' Group='Logical' Length='2'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>NEG</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The contents of the Accumulator are negated (two’s complement). This is the same as subtracting the contents of the Accumulator from zero. Note that 80H is left unchanged.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>NEG</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The contents of the Accumulator are negated (two’s complement). This is the same as subtracting the contents of the Accumulator from zero. Note that 80H is left unchanged.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='45' Function='RETN' Group='Interrupt' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>RETN</Mnemonic>
      <Status>Documented</Status>
      <Cycles>4(14)</Cycles>
      <Flags>------</Flags>
      <Description>This instruction is used at the end of a non-maskable interrupts service routine to restore the contents of the Program Counter (PC) (analogous to the RET instruction). </Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='46' Function='IM' Group='Interrupt' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>IM</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>Value-0</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>------</Flags>
      <Description>The IM 0 instruction sets interrupt mode 0. In this mode, the interrupting device can insert any instruction on the data bus for execution by the CPU. The first byte of a multi-byte instruction is read during the interrupt acknowledge cycle. Subsequent bytes are read in by a normal memory read sequence.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='47' Function='LOAD' Group='8-Bit Load' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-I</Arg>
        <Arg encoding='Direct'>ByteReg-A</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(9)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of the Accumulator are loaded to the Interrupt Control Vector Register, I.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='4A' Function='ADD-CY' Group='16-Bit Arithmetic' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>ADC</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordReg-HL</Arg>
        <Arg encoding='WordReg'>WordReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>4(15)</Cycles>
      <Flags>SZHP0C</Flags>
      <Description>The contents of register pair ss (any of register pairs BC, DE, HL, or SP) are added with the Carry flag (C flag in the F register) to the contents of register pair HL, and the result is stored in HL</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='4B' Function='LOAD' Group='16-Bit Load' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='WordReg'>WordReg</Arg>
        <Arg encoding='WordImmidate'>AddressPtr</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>6(20)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of address (nn) are loaded to the low order portion of register pair dd, and the contents of the next highest memory address (nn+1) are loaded to the high order portion of dd.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='4C' Function='NEG' Group='Logical' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>NEG</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
      </Arguments>
      <Status>ExecuteOnly</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The contents of the Accumulator are negated (two’s complement). This is the same as subtracting the contents of the Accumulator from zero. Note that 80H is left unchanged.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='4D' Function='RETI' Group='Interrupt' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>RETI</Mnemonic>
      <Status>Documented</Status>
      <Cycles>4(14)</Cycles>
      <Flags>------</Flags>
      <Description>This instruction is used at the end of a maskable interrupt service</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='4E' Function='IM' Group='Interrupt' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>IM</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>Value-0</Arg>
      </Arguments>
      <Status>ExecuteOnly</Status>
      <Cycles>2(8)</Cycles>
      <Flags>------</Flags>
      <Description>The IM 0 instruction sets interrupt mode 0. In this mode, the interrupting device can insert any instruction on the data bus for execution by the CPU. The first byte of a multi-byte instruction is read during the interrupt acknowledge cycle. Subsequent bytes are read in by a normal memory read sequence.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='4F' Function='LOAD' Group='8-Bit Load' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-R</Arg>
        <Arg encoding='Direct'>ByteReg-A</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(9)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of the Accumulator are loaded to the Memory Refresh register R</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='54' Function='NEG' Group='Logical' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>NEG</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
      </Arguments>
      <Status>ExecuteOnly</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The contents of the Accumulator are negated (two’s complement). This is the same as subtracting the contents of the Accumulator from zero. Note that 80H is left unchanged.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='55' Function='RETN' Group='Interrupt' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>RETN</Mnemonic>
      <Status>Documented</Status>
      <Cycles>4(14)</Cycles>
      <Flags>------</Flags>
      <Description>This instruction is used at the end of a non-maskable interrupts service routine to restore the contents of the Program Counter (PC) (analogous to the RET instruction). </Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='56' Function='IM' Group='Interrupt' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>IM</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>Value-1</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>------</Flags>
      <Description>The IM 1 instruction sets interrupt mode 1. In this mode, the processor responds to an interrupt by executing a restart to location 0038H.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='57' Function='LOAD' Group='8-Bit Load' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Direct'>ByteReg-I</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(9)</Cycles>
      <Flags>SZ0?0-</Flags>
      <Description>The contents of the Interrupt Vector Register I are loaded to the Accumulator</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='5C' Function='NEG' Group='Logical' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>NEG</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
      </Arguments>
      <Status>ExecuteOnly</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The contents of the Accumulator are negated (two’s complement). This is the same as subtracting the contents of the Accumulator from zero. Note that 80H is left unchanged.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='5D' Function='RETN' Group='Interrupt' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>RETN</Mnemonic>
      <Status>Documented</Status>
      <Cycles>4(14)</Cycles>
      <Flags>------</Flags>
      <Description>This instruction is used at the end of a non-maskable interrupts service routine to restore the contents of the Program Counter (PC) (analogous to the RET instruction). </Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='5E' Function='IM' Group='Interrupt' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>IM</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>Value-2</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>------</Flags>
      <Description>The IM 2 instruction sets the vectored interrupt mode 2. This mode allows an indirect call to any memory location by an 8-bit vector supplied from the peripheral device. This vector then becomes the least-significant eight bits of the indirect pointer, while the I register in the CPU provides the most- significant eight bits. This address points to an address in a vector table that is the starting address for the interrupt service routine</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='5F' Function='LOAD' Group='8-Bit Load' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Direct'>ByteReg-R</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(9)</Cycles>
      <Flags>SZ0?0-</Flags>
      <Description>The contents of Memory Refresh Register R are loaded to the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='64' Function='NEG' Group='Logical' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>NEG</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
      </Arguments>
      <Status>ExecuteOnly</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The contents of the Accumulator are negated (two’s complement). This is the same as subtracting the contents of the Accumulator from zero. Note that 80H is left unchanged.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='65' Function='RETN' Group='Interrupt' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>RETN</Mnemonic>
      <Status>Documented</Status>
      <Cycles>4(14)</Cycles>
      <Flags>------</Flags>
      <Description>This instruction is used at the end of a non-maskable interrupts service routine to restore the contents of the Program Counter (PC) (analogous to the RET instruction). </Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='66' Function='IM' Group='Interrupt' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>IM</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>Value-0</Arg>
      </Arguments>
      <Status>ExecuteOnly</Status>
      <Cycles>2(8)</Cycles>
      <Flags>------</Flags>
      <Description>The IM 0 instruction sets interrupt mode 0. In this mode, the interrupting device can insert any instruction on the data bus for execution by the CPU. The first byte of a multi-byte instruction is read during the interrupt acknowledge cycle. Subsequent bytes are read in by a normal memory read sequence.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='67' Function='ROLL-R' Group='Logical' Length='2'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>RRD</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(18)</Cycles>
      <Flags>SZ0P0-</Flags>
      <Description>The contents of the low order four bits (bits 3, 2, 1, and 0) of memory location (HL) are copied to the low order four bits of the Accumulator (register A). The previous contents of the low order four bits of the Accumulator are copied to the high order four bits (7, 6, 5, and 4) of location (HL); and the previous contents of the high order four bits of (HL) are copied to the low order four bits of (HL). The contents of the high order bits of the Accumulator are unaffected.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>RRD</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
        <Arg encoding='Direct' hidden='true'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(18)</Cycles>
      <Flags>SZ0P0-</Flags>
      <Description>The contents of the low order four bits (bits 3, 2, 1, and 0) of memory location (HL) are copied to the low order four bits of the Accumulator (register A). The previous contents of the low order four bits of the Accumulator are copied to the high order four bits (7, 6, 5, and 4) of location (HL); and the previous contents of the high order four bits of (HL) are copied to the low order four bits of (HL). The contents of the high order bits of the Accumulator are unaffected.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='6C' Function='NEG' Group='Logical' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>NEG</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
      </Arguments>
      <Status>ExecuteOnly</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The contents of the Accumulator are negated (two’s complement). This is the same as subtracting the contents of the Accumulator from zero. Note that 80H is left unchanged.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='6D' Function='RETN' Group='Interrupt' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>RETN</Mnemonic>
      <Status>Documented</Status>
      <Cycles>4(14)</Cycles>
      <Flags>------</Flags>
      <Description>This instruction is used at the end of a non-maskable interrupts service routine to restore the contents of the Program Counter (PC) (analogous to the RET instruction). </Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='6E' Function='IM' Group='Interrupt' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>IM</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>Value-0</Arg>
      </Arguments>
      <Status>ExecuteOnly</Status>
      <Cycles>2(8)</Cycles>
      <Flags>------</Flags>
      <Description>The IM 0 instruction sets interrupt mode 0. In this mode, the interrupting device can insert any instruction on the data bus for execution by the CPU. The first byte of a multi-byte instruction is read during the interrupt acknowledge cycle. Subsequent bytes are read in by a normal memory read sequence.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='6F' Function='ROLL-L' Group='Logical' Length='2'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>RLD</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Direct'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(18)</Cycles>
      <Flags>SZ0P0-</Flags>
      <Description>The contents of the low order four bits (bits 3, 2, 1, and 0) of the memory location (HL) are copied to the high order four bits (7, 6, 5, and 4) of that same memory location; the previous contents of those high order four bits are copied to the low order four bits of the Accumulator (register A); and the previous contents of the low order four bits of the Accumulator are copied to the low order four bits of memory location (HL). The contents of the high order bits of the Accumulator are unaffected</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>RLD</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
        <Arg encoding='Direct' hidden='true'>WordRegPtr-HL</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(18)</Cycles>
      <Flags>SZ0P0-</Flags>
      <Description>The contents of the low order four bits (bits 3, 2, 1, and 0) of the memory location (HL) are copied to the high order four bits (7, 6, 5, and 4) of that same memory location; the previous contents of those high order four bits are copied to the low order four bits of the Accumulator (register A); and the previous contents of the low order four bits of the Accumulator are copied to the low order four bits of memory location (HL). The contents of the high order bits of the Accumulator are unaffected</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='70' Function='IN' Group='I/O' Length='2'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>IN</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteRegPtr-C</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>2(12)</Cycles>
      <Flags>SZ0P0-</Flags>
      <Description>The contents of register C are placed on the bottom half (A0 through A7) of the address bus to select the I/O device at one of 256 possible ports. The contents of Register B are placed on the top half (A8 through A15) of the address bus at this time. One byte from the port is then discarded</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>IN</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-C</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>2(12)</Cycles>
      <Flags>SZ0P0-</Flags>
      <Description>The contents of register C are placed on the bottom half (A0 through A7) of the address bus to select the I/O device at one of 256 possible ports. The contents of Register B are placed on the top half (A8 through A15) of the address bus at this time. One byte from the port is then discarded</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='71' Function='OUT' Group='I/O' Length='2'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>OUT</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteRegPtr-C</Arg>
        <Arg encoding='Direct'>Value-0</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>2(12)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of register C are placed on the bottom half (A0 through A7) of the address bus to select the I/O device at one of 256 possible ports. The contents of Register B are placed on the top half (A8 through A15) of the address bus at this time. Then a zero is placed on a the data bus.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>OUT</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-C</Arg>
        <Arg encoding='Direct'>Value-0</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>2(12)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of register C are placed on the bottom half (A0 through A7) of the address bus to select the I/O device at one of 256 possible ports. The contents of Register B are placed on the top half (A8 through A15) of the address bus at this time. Then a zero is placed on a the data bus.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='74' Function='NEG' Group='Logical' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>NEG</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
      </Arguments>
      <Status>ExecuteOnly</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The contents of the Accumulator are negated (two’s complement). This is the same as subtracting the contents of the Accumulator from zero. Note that 80H is left unchanged.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='75' Function='RETN' Group='Interrupt' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>RETN</Mnemonic>
      <Status>Documented</Status>
      <Cycles>4(14)</Cycles>
      <Flags>------</Flags>
      <Description>This instruction is used at the end of a non-maskable interrupts service routine to restore the contents of the Program Counter (PC) (analogous to the RET instruction). </Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='76' Function='IM' Group='Interrupt' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>IM</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>Value-1</Arg>
      </Arguments>
      <Status>ExecuteOnly</Status>
      <Cycles>2(8)</Cycles>
      <Flags>------</Flags>
      <Description>The IM 1 instruction sets interrupt mode 1. In this mode, the processor responds to an interrupt by executing a restart to location 0038H.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='7C' Function='NEG' Group='Logical' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>NEG</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
      </Arguments>
      <Status>ExecuteOnly</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The contents of the Accumulator are negated (two’s complement). This is the same as subtracting the contents of the Accumulator from zero. Note that 80H is left unchanged.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='7D' Function='RETN' Group='Interrupt' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>RETN</Mnemonic>
      <Status>Documented</Status>
      <Cycles>4(14)</Cycles>
      <Flags>------</Flags>
      <Description>This instruction is used at the end of a non-maskable interrupts service routine to restore the contents of the Program Counter (PC) (analogous to the RET instruction). </Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='7E' Function='IM' Group='Interrupt' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>IM</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>Value-2</Arg>
      </Arguments>
      <Status>ExecuteOnly</Status>
      <Cycles>2(8)</Cycles>
      <Flags>------</Flags>
      <Description>The IM 2 instruction sets the vectored interrupt mode 2. This mode allows an indirect call to any memory location by an 8-bit vector supplied from the peripheral device. This vector then becomes the least-significant eight bits of the indirect pointer, while the I register in the CPU provides the most- significant eight bits. This address points to an address in a vector table that is the starting address for the interrupt service routine</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='A0' Function='LOAD_I' Group='Block' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>LDI</Mnemonic>
      <Status>Documented</Status>
      <Cycles>4(16)</Cycles>
      <Flags>--0P0-</Flags>
      <Description>A byte of data is transferred from the memory location addressed, by the contents of the HL register pair to the memory location addressed by the contents of the DE register pair. Then both these register pairs are incremented and the BC (Byte Counter) register pair is decremented.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='A1' Function='CMP_I' Group='Block' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>CPI</Mnemonic>
      <Status>Documented</Status>
      <Cycles>4(16)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The contents of the memory location addressed by the HL register is compared with the contents of the Accumulator. In case of a true compare, a condition bit is set. Then HL is incremented and the Byte Counter (register pair BC) is decremented.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='A2' Function='IN_I' Group='Block' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>INI</Mnemonic>
      <Status>Documented</Status>
      <Cycles>4(16)</Cycles>
      <Flags>?Z??1-</Flags>
      <Description>The contents of register C are placed on the bottom half (A0 through A7) of the address bus to select the I/O device at one of 256 possible ports. Register B may be used as a byte counter, and its contents are placed on the top half (A8 through A15) of the address bus at this time. Then one byte from the selected port is placed on the data bus and written to the CPU. The contents of the HL register pair are then placed on the address bus and the input byte is written to the corresponding location of memory. Finally, the byte counter is decremented and register pair HL is incremented</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='A3' Function='OUT_I' Group='Block' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>OUTI</Mnemonic>
      <Status>Documented</Status>
      <Cycles>4(16)</Cycles>
      <Flags>?Z??1-</Flags>
      <Description>The contents of the HL register pair are placed on the address bus to select a location in memory. The byte contained in this memory location is temporarily stored in the CPU. Then, after the byte counter (B) is decremented, the contents of register C are placed on the bottom half (A0 through A7) of the address bus to select the I/O device at one of 256 possible ports. Register B may be used as a byte counter, and its decremented value is placed on the top half (A8 through A15) of the address bus. The byte to be output is placed on the data bus and written to a selected peripheral device. Finally, the register pair HL is incremented.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='A8' Function='LOAD_D' Group='Block' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>LDD</Mnemonic>
      <Status>Documented</Status>
      <Cycles>4(16)</Cycles>
      <Flags>--0P0-</Flags>
      <Description>This 2-byte instruction transfers a byte of data from the memory location addressed by the contents of the HL register pair to the memory location addressed by the contents of the DE register pair. Then both of these register pairs including the BC (Byte Counter) register pair are decremented.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='A9' Function='CMP_D' Group='Block' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>CPD</Mnemonic>
      <Status>Documented</Status>
      <Cycles>4(16)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The contents of the memory location addressed by the HL register pair is compared with the contents of the Accumulator. In case of a true compare, a condition bit is set. The HL and Byte Counter (register pair BC) are decremented.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='AA' Function='IN_D' Group='Block' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>IND</Mnemonic>
      <Status>Documented</Status>
      <Cycles>4(16)</Cycles>
      <Flags>?Z??1-</Flags>
      <Description>The contents of register C are placed on the bottom half (A0 through A7) of the address bus to select the I/O device at one of 256 possible ports. Register B may be used as a byte counter, and its contents are placed on the top half (A8 through A15) of the address bus at this time. Then one byte from the selected port is placed on the data bus and written to the CPU. The contents of the HL register pair are placed on the address bus and the input byte is written to the corresponding location of memory. Finally, the byte counter and register pair HL are decremented.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='AB' Function='OUT_D' Group='Block' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>OUTD</Mnemonic>
      <Status>Documented</Status>
      <Cycles>4(16)</Cycles>
      <Flags>?Z??1-</Flags>
      <Description>The contents of the HL register pair are placed on the address bus to select a location in memory. The byte contained in this memory location is temporarily stored in the CPU. Then, after the byte counter (B) is decremented, the contents of register C are placed on the bottom half (A0 through A7) of the address bus to select the I/O device at one of 256 possible ports. Register B may be used as a byte counter, and its decremented value is placed on the top half (A8 through A15) of the address bus at this time. Next, the byte to be output is placed on the data bus and written to the selected peripheral device. Finally, the register pair HL is decremented.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='B0' Function='LOAD_IR' Group='Block' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>LDIR</Mnemonic>
      <Status>Documented</Status>
      <Cycles>5(21)</Cycles>
      <Flags>--000-</Flags>
      <Description>This 2-byte instruction transfers a byte of data from the memory location addressed by the contents of the HL register pair to the memory location addressed by the DE register pair. Both these register pairs are incremented and the BC (Byte Counter) register pair is decremented. If decrementing causes the BC to go to zero, the instruction is terminated. If BC is not zero, the program counter is decremented by two and the instruction is repeated. Interrupts are recognized and two refresh cycles are executed after each data transfer. When BC is set to zero prior to instruction execution, the instruction loops through 64 Kbytes</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='B1' Function='CMP_IR' Group='Block' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>CPIR</Mnemonic>
      <Status>Documented</Status>
      <Cycles>5(21)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The contents of the memory location addressed by the HL register pair is compared with the contents of the Accumulator. In case of a true compare, a condition bit is set. HL is incremented and the Byte Counter (register pair BC) is decremented. If decrementing causes BC to go to zero or if A = (HL), the instruction is terminated. If BC is not zero and A ≠ (HL), the program counter is decremented by two and the instruction is repeated. Interrupts are recognized and two refresh cycles are executed after each data transfer. If BC is set to zero before instruction execution, the instruction loops through 64 Kbytes if no match is found.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='B2' Function='IN_IR' Group='Block' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>INIR</Mnemonic>
      <Status>Documented</Status>
      <Cycles>5(21)</Cycles>
      <Flags>?Z??1-</Flags>
      <Description>The contents of register C are placed on the bottom half (A0 through A7) of the address bus to select the I/O device at one of 256 possible ports. Register B is used as a byte counter, and its contents are placed on the top half (A8 through A15) of the address bus at this time. Then one byte from the selected port is placed on the data bus and written to the CPU. The contents of the HL register pair are placed on the address bus and the input byte is written to the corresponding location of memory. Then register pair HL is incremented, the byte counter is decremented. If decrementing causes B to go to zero, the instruction is terminated. If B is not zero, the PC is decremented by two and the instruction repeated. Interrupts are recognized and two refresh cycles execute after each data transfer.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='B3' Function='OUT_IR' Group='Block' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>OTIR</Mnemonic>
      <Status>Documented</Status>
      <Cycles>5(21)</Cycles>
      <Flags>?Z??1-</Flags>
      <Description>The contents of the HL register pair are placed on the address bus to select a location in memory. The byte contained in this memory location is tempo- rarily stored in the CPU. Then, after the byte counter (B) is decremented, the contents of register C are placed on the bottom half (A0 through A7) of the address bus to select the I/O device at one of 256 possible ports. Register B may be used as a byte counter, and its decremented value is placed on the top half (A8 through A15) of the address bus at this time. Next, the byte to be output is placed on the data bus and written to the selected peripheral device. Then register pair HL is incremented. If the decremented B register is not zero, the Program Counter (PC) is decremented by two and the instruction is repeated. If B has gone to zero, the instruction is terminated. Interrupts are recognized and two refresh cycles are executed after each data transfer.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='B8' Function='LOAD_DR' Group='Block' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>LDDR</Mnemonic>
      <Status>Documented</Status>
      <Cycles>5(21)</Cycles>
      <Flags>--000-</Flags>
      <Description>This 2-byte instruction transfers a byte of data from the memory location addressed by the contents of the HL register pair to the memory location addressed by the contents of the DE register pair. Then both of these registers, as well as the BC (Byte Counter), are decremented. If decrementing causes BC to go to zero, the instruction is terminated. If BC is not zero, the program counter is decremented by two and the instruction is repeated. Interrupts are recognized and two refresh cycles execute after each data transfer. When BC is set to zero, prior to instruction execution, the instruction loops through 64 Kbytes.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='B9' Function='CMP_DR' Group='Block' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>CPDR</Mnemonic>
      <Status>Documented</Status>
      <Cycles>5(21)</Cycles>
      <Flags>SZH01C</Flags>
      <Description>The contents of the memory location addressed by the HL register pair is compared with the contents of the Accumulator. In case of a true compare, a condition bit is set. The HL and BC (Byte Counter) register pairs are decremented. If decrementing causes the BC to go to zero or if A = (HL), the instruction is terminated. If BC is not zero and A = (HL), the program counter is decremented by two and the instruction is repeated. Interrupts are recognized and two refresh cycles execute after each data transfer. When BC is set to zero, prior to instruction execution, the instruction loops through 64 Kbytes if no match is found.</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='BA' Function='IN_DR' Group='Block' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>INDR</Mnemonic>
      <Status>Documented</Status>
      <Cycles>5(21)</Cycles>
      <Flags>?Z??1-</Flags>
      <Description>The contents of register C are placed on the bottom half (A0 through A7) of the address bus to select the I/O device at one of 256 possible ports. Register B is used as a byte counter, and its contents are placed on the top half (A8 through A15) of the address bus at this time. Then one byte from the selected port is placed on the data bus and written to the CPU. The contents of the HL register pair are placed on the address bus and the input byte is written to the corresponding location of memory. Then HL and the byte counter are decremented. If decrementing causes B to go to zero, the instruction is terminated. If B is not zero, the PC is decremented by two and the instruction repeated. Interrupts are recognized and two refresh cycles are executed after each data transfer</Description>
    </Encoding>
  </Opcode>
  <Opcode Prefix='ED' Value='BB' Function='OUT_DR' Group='Block' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>OTDR</Mnemonic>
      <Status>Documented</Status>
      <Cycles>5(21)</Cycles>
      <Flags>?Z??1-</Flags>
      <Description>The contents of the HL register pair are placed on the address bus to select a location in memory. The byte contained in this memory location is tempo- rarily stored in the CPU. Then, after the byte counter (B) is decremented, the contents of register C are placed on the bottom half (A0 through A7) of the address bus to select the I/O device at one of 256 possible ports. Regis- ter B may be used as a byte counter, and its decremented value is placed on the top half (A8 through A15) of the address bus at this time. Next, the byte to be output is placed on the data bus and written to the selected peripheral device. Then, register pair HL is decremented and if the decremented B register is not zero, the Program Counter (PC) is decremented by two and the instruction is repeated. If B has gone to zero, the instruction is termi- nated. Interrupts are recognized and two refresh cycles are executed after each data transfer.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='04' Function='INC' Group='8-Bit Arithmetic' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>INC</Mnemonic>
      <Arguments>
        <Arg encoding='Dest'>ByteReg-Izb</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZHP0-</Flags>
      <Description>Register r is incremented</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='05' Function='DEC' Group='8-Bit Arithmetic' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>DEC</Mnemonic>
      <Arguments>
        <Arg encoding='Dest'>ByteReg-Izb</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The byte specified by the m operand is decremented</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='06' Function='LOAD' Group='8-Bit Load' Length='3'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='Dest'>ByteReg-Izb</Arg>
        <Arg encoding='ByteImmidate'>Byte</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>3(11)</Cycles>
      <Flags>------</Flags>
      <Description>The 8-bit integer n is loaded to any register r.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='09' Function='ADD' Group='16-Bit Arithmetic' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>ADD</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordReg-Iz</Arg>
        <Arg encoding='WordReg'>WordReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>4(15)</Cycles>
      <Flags>--H-0C</Flags>
      <Description>The contents of register pair pp (any of register pairs BC, DE, IX, or SP) are added to the contents of the Index Register IX, and the results are stored in IX</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='21' Function='LOAD' Group='16-Bit Load' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordReg-Iz</Arg>
        <Arg encoding='WordImmidate'>Word</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>4(14)</Cycles>
      <Flags>------</Flags>
      <Description>Integer nn is loaded to the Index Register IX. The first n operand after the Op Code is the low order byte.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='22' Function='LOAD' Group='16-Bit Load' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='WordImmidate'>AddressPtr</Arg>
        <Arg encoding='Direct'>WordReg-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>6(20)</Cycles>
      <Flags>------</Flags>
      <Description>The low order byte in Index Register IX is loaded to memory address (nn); the upper order byte is loaded to the next highest address (nn+1). The first n operand after the Op Code is the low order byte of nn</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='23' Function='INC' Group='16-Bit Arithmetic' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>INC</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordReg-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(10)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of the Index Register IX are incremented</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='29' Function='ADD' Group='16-Bit Arithmetic' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>ADD</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordReg-Iz</Arg>
        <Arg encoding='Direct'>WordReg-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>4(15)</Cycles>
      <Flags>--H-0C</Flags>
      <Description>The contents of register pair pp (any of register pairs BC, DE, IX, or SP) are added to the contents of the Index Register IX, and the results are stored in IX</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='2A' Function='LOAD' Group='16-Bit Load' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordReg-Iz</Arg>
        <Arg encoding='WordImmidate'>AddressPtr</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>6(20)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of the address (nn) are loaded to the low order portion of Index Register IX, and the contents of the next highest memory address (nn+1) are loaded to the high order portion of IX. The first n operand after the Op Code is the low order byte of nn.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='2B' Function='DEC' Group='16-Bit Arithmetic' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>DEC</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordReg-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(10)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of Index Register IX are decremented.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='34' Function='INC' Group='8-Bit Arithmetic' Length='3'>
    <Encoding Platform='z80'>
      <Mnemonic>INC</Mnemonic>
      <Arguments>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>SZHP0-</Flags>
      <Description>The contents of the Index Register IX (register pair IX) are added to a two’s complement displacement integer d to point to an address in memory. The contents of this address are then incremented</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='35' Function='DEC' Group='8-Bit Arithmetic' Length='3'>
    <Encoding Platform='z80'>
      <Mnemonic>DEC</Mnemonic>
      <Arguments>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The byte specified by the m operand is decremented</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='36' Function='LOAD' Group='8-Bit Load' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
        <Arg encoding='ByteImmidate'>Byte</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(19)</Cycles>
      <Flags>------</Flags>
      <Description>The n operand is loaded to the memory address specified by the sum of the Index Register IX and the two’s complement displacement operand d.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='40' Function='LOAD' Group='8-Bit Load' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='Dest'>ByteReg-Izb</Arg>
        <Arg encoding='Source'>ByteReg-Izb</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of any register r' are loaded to any other register r.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='46' Function='LOAD' Group='8-Bit Load' Length='3'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='Dest'>ByteReg</Arg>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(19)</Cycles>
      <Flags>------</Flags>
      <Description>The operand (IX+d), (the contents of the Index Register IX summed with a two’s complement displacement integer d) is loaded to register r</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='70' Function='LOAD' Group='8-Bit Load' Length='3'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(19)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of register r are loaded to the memory address specified by the contents of Index Register IX summed with d, a two’s complement displacement integer.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='80' Function='ADD' Group='8-Bit Arithmetic' Length='1'>
    <Encoding Platform='z80'>
      <Mnemonic>ADD</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Source'>ByteReg-Izb</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZHP0C</Flags>
      <Description>The contents of register r are added to the contents of the Accumulator, and the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='86' Function='ADD' Group='8-Bit Arithmetic' Length='3'>
    <Encoding Platform='z80'>
      <Mnemonic>ADD</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(19)</Cycles>
      <Flags>SZHP0C</Flags>
      <Description>The contents of the Index Register (register pair IX) is added to a two’s complement displacement d to point to an address in memory. The contents of this address is then added to the contents of the Accumulator and the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='88' Function='ADD-CY' Group='8-Bit Arithmetic' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>ADC</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Source'>ByteReg-Izb</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZHP0C</Flags>
      <Description>The s operand, along with the Carry Flag (C in the F register) is added to the contents of the Accumulator, and the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='8E' Function='ADD-CY' Group='8-Bit Arithmetic' Length='3'>
    <Encoding Platform='z80'>
      <Mnemonic>ADC</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(19)</Cycles>
      <Flags>SZHP0C</Flags>
      <Description>The s operand, along with the Carry Flag (C in the F register) is added to the contents of the Accumulator, and the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='90' Function='SUB' Group='8-Bit Arithmetic' Length='2'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>SUB</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Source'>ByteReg-Izb</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZ0P1C</Flags>
      <Description>The s operand is subtracted from the contents of the Accumulator, and the result is stored in the Accumulator.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>SUB</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
        <Arg encoding='Source'>ByteReg-Izb</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZ0P1C</Flags>
      <Description>The s operand is subtracted from the contents of the Accumulator, and the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='96' Function='SUB' Group='8-Bit Arithmetic' Length='3'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>SUB</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(19)</Cycles>
      <Flags>SZ0P1C</Flags>
      <Description>The s operand is subtracted from the contents of the Accumulator, and the result is stored in the Accumulator.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>SUB</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(19)</Cycles>
      <Flags>SZ0P1C</Flags>
      <Description>The s operand is subtracted from the contents of the Accumulator, and the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='98' Function='SUB-CY' Group='8-Bit Arithmetic' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>SBC</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Source'>ByteReg-Izb</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZ0P1C</Flags>
      <Description>The s operand, along with the Carry flag (C in the F register) is subtracted from the contents of the Accumulator, and the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='9E' Function='SUB-CY' Group='8-Bit Arithmetic' Length='3'>
    <Encoding Platform='z80'>
      <Mnemonic>SBC</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(19)</Cycles>
      <Flags>SZ0P1C</Flags>
      <Description>The s operand, along with the Carry flag (C in the F register) is subtracted from the contents of the Accumulator, and the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='A0' Function='AND' Group='Logical' Length='2'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>AND</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Source'>ByteReg-Izb</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZ1P00</Flags>
      <Description>A logical AND operation is performed between the byte specified by the s operand and the byte contained in the Accumulator; the result is stored in the Accumulator</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>AND</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
        <Arg encoding='Source'>ByteReg-Izb</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZ1P00</Flags>
      <Description>A logical AND operation is performed between the byte specified by the s operand and the byte contained in the Accumulator; the result is stored in the Accumulator</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='A6' Function='AND' Group='Logical' Length='3'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>AND</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(19)</Cycles>
      <Flags>SZ1P00</Flags>
      <Description>A logical AND operation is performed between the byte specified by the s operand and the byte contained in the Accumulator; the result is stored in the Accumulator</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>AND</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(19)</Cycles>
      <Flags>SZ1P00</Flags>
      <Description>A logical AND operation is performed between the byte specified by the s operand and the byte contained in the Accumulator; the result is stored in the Accumulator</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='A8' Function='XOR' Group='Logical' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>XOR</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Source'>ByteReg-Izb</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZ0P00</Flags>
      <Description>The logical exclusive-OR operation is performed between the byte specified by the s operand and the byte contained in the Accumulator; the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='AE' Function='XOR' Group='Logical' Length='3'>
    <Encoding Platform='z80'>
      <Mnemonic>XOR</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(19)</Cycles>
      <Flags>SZ0P00</Flags>
      <Description>The logical exclusive-OR operation is performed between the byte specified by the s operand and the byte contained in the Accumulator; the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='B0' Function='OR' Group='Logical' Length='2'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>OR</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Source'>ByteReg-Izb</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZ0P00</Flags>
      <Description>A logical OR operation is performed between the byte specified by the s operand and the byte contained in the Accumulator; the result is stored in the Accumulator.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>OR</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
        <Arg encoding='Source'>ByteReg-Izb</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZ0P00</Flags>
      <Description>A logical OR operation is performed between the byte specified by the s operand and the byte contained in the Accumulator; the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='B6' Function='OR' Group='Logical' Length='3'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>OR</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(19)</Cycles>
      <Flags>SZ0P00</Flags>
      <Description>A logical OR operation is performed between the byte specified by the s operand and the byte contained in the Accumulator; the result is stored in the Accumulator.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>OR</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(19)</Cycles>
      <Flags>SZ0P00</Flags>
      <Description>A logical OR operation is performed between the byte specified by the s operand and the byte contained in the Accumulator; the result is stored in the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='B8' Function='CMP' Group='Logical' Length='2'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>CP</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='Source'>ByteReg-Izb</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The contents of the s operand are compared with the contents of the Accumulator. If there is a true compare, the Z flag is set. The execution of this instruction does not affect the contents of the Accumulator.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>CP</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
        <Arg encoding='Source'>ByteReg-Izb</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The contents of the s operand are compared with the contents of the Accumulator. If there is a true compare, the Z flag is set. The execution of this instruction does not affect the contents of the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='BE' Function='CMP' Group='Logical' Length='3'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>CP</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>ByteReg-A</Arg>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(19)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The contents of the s operand are compared with the contents of the Accumulator. If there is a true compare, the Z flag is set. The execution of this instruction does not affect the contents of the Accumulator.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>CP</Mnemonic>
      <Arguments>
        <Arg encoding='Direct' hidden='true'>ByteReg-A</Arg>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(19)</Cycles>
      <Flags>SZHP1C</Flags>
      <Description>The contents of the s operand are compared with the contents of the Accumulator. If there is a true compare, the Z flag is set. The execution of this instruction does not affect the contents of the Accumulator.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='E1' Function='POP' Group='Stack' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>POP</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordReg-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>4(14)</Cycles>
      <Flags>------</Flags>
      <Description>The top two bytes of the external memory LIFO (last-in, first-out) Stack are popped to Index Register IX.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='E3' Function='EX' Group='16-Bit Load' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>EX</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordRegPtr-SP</Arg>
        <Arg encoding='Direct'>WordReg-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>------</Flags>
      <Description>The low order byte in Index Register IX is exchanged with the contents of the memory address specified by the contents of register pair SP (Stack Pointer), and the high order byte of IX is exchanged with the next highest memory address (SP+1).</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='E5' Function='PUSH' Group='Stack' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>PUSH</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordReg-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(15)</Cycles>
      <Flags>------</Flags>
      <Description>The contents of the Index Register IX are pushed to the external memory LIFO (last-in, first-out) Stack.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='E9' Function='JMP' Group='Branch' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>JP</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordReg-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(8)</Cycles>
      <Flags>------</Flags>
      <Description>The Program Counter (register pair PC) is loaded with the contents of the IX Register Pair. The next instruction is fetched from the location designated by the new contents of the PC.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Value='F9' Function='LOAD' Group='16-Bit Load' Length='2'>
    <Encoding Platform='z80'>
      <Mnemonic>LD</Mnemonic>
      <Arguments>
        <Arg encoding='Direct'>WordReg-SP</Arg>
        <Arg encoding='Direct'>WordReg-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>2(10)</Cycles>
      <Flags>------</Flags>
      <Description>The 2-byte contents of Index Register IX are loaded to the Stack Pointer (SP).</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Prefix='CB' Value='00' Function='RL' Group='Logical' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>RLC</Mnemonic>
      <Arguments>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>The contents of the memory address specified by the sum of the contents of the Index Register IX and a two’s complement displacement integer d, are rotated left 1-bit position. The content of bit 7 is copied to the Carry flag and also to bit 0. Bit 0 is the least-significant bit. The result is stored in register r.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Prefix='CB' Value='06' Function='RL' Group='Logical' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>RLC</Mnemonic>
      <Arguments>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>The contents of the memory address specified by the sum of the contents of the Index Register IX and a two’s complement displacement integer d, are rotated left 1-bit position. The content of bit 7 is copied to the Carry flag and also to bit 0. Bit 0 is the least-significant bit</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Prefix='CB' Value='08' Function='RR' Group='Logical' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>RRC</Mnemonic>
      <Arguments>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>The contents of the m operand are rotated right 1-bit position. The content of bit 0 is copied to the Carry flag and also to bit 7. Bit 0 is the least- significant bit. The result is stored in register r.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Prefix='CB' Value='0E' Function='RR' Group='Logical' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>RRC</Mnemonic>
      <Arguments>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>The contents of the m operand are rotated right 1-bit position. The content of bit 0 is copied to the Carry flag and also to bit 7. Bit 0 is the least- significant bit.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Prefix='CB' Value='10' Function='RL-CY' Group='Logical' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>RL</Mnemonic>
      <Arguments>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>The contents of the m operand are rotated left 1-bit position. The content of bit 7 is copied to the Carry flag and the previous content of the Carry flag is copied to bit 0. The result is stored in register r.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Prefix='CB' Value='16' Function='RL-CY' Group='Logical' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>RL</Mnemonic>
      <Arguments>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>The contents of the m operand are rotated left 1-bit position. The content of bit 7 is copied to the Carry flag and the previous content of the Carry flag is copied to bit 0.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Prefix='CB' Value='18' Function='RR-CY' Group='Logical' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>RR</Mnemonic>
      <Arguments>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>The contents of operand m are rotated right 1-bit position through the Carry flag. The content of bit 0 is copied to the Carry flag and the previous content of the Carry flag is copied to bit 7. Bit 0 is the least-significant bit. The result is stored in register r.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Prefix='CB' Value='1E' Function='RR-CY' Group='Logical' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>RR</Mnemonic>
      <Arguments>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>The contents of operand m are rotated right 1-bit position through the Carry flag. The content of bit 0 is copied to the Carry flag and the previous content of the Carry flag is copied to bit 7. Bit 0 is the least-significant bit.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Prefix='CB' Value='20' Function='SL-Signed' Group='Logical' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>SLA</Mnemonic>
      <Arguments>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>An arithmetic shift left 1-bit position is performed on the contents of operand m. The content of bit 7 is copied to the Carry flag. Bit 0 is the least-significant bit. The result is stored in register r.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Prefix='CB' Value='26' Function='SL-Signed' Group='Logical' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>SLA</Mnemonic>
      <Arguments>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>An arithmetic shift left 1-bit position is performed on the contents of operand m. The content of bit 7 is copied to the Carry flag. Bit 0 is the least-significant bit.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Prefix='CB' Value='28' Function='SR-Signed' Group='Logical' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>SRA</Mnemonic>
      <Arguments>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>An arithmetic shift right 1-bit position is performed on the contents of operand m. The content of bit 0 is copied to the Carry flag and the previous content of bit 7 is unchanged. Bit 0 is the least-significant bit. The result is stored in register r.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Prefix='CB' Value='2E' Function='SR-Signed' Group='Logical' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>SRA</Mnemonic>
      <Arguments>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>An arithmetic shift right 1-bit position is performed on the contents of operand m. The content of bit 0 is copied to the Carry flag and the previous content of bit 7 is unchanged. Bit 0 is the least-significant bit.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Prefix='CB' Value='30' Function='SL-L' Group='Logical' Length='4'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>SL1</Mnemonic>
      <Arguments>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>An arithmetic shift left 1-bit position is performed on the contents of operand m. The content of bit 7 is copied to the Carry flag. Bit 0 is set. Bit 0 is the least-significant bit. The result is stored in register r.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>SLL</Mnemonic>
      <Arguments>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>An arithmetic shift left 1-bit position is performed on the contents of operand m. The content of bit 7 is copied to the Carry flag. Bit 0 is set. Bit 0 is the least-significant bit. The result is stored in register r.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Prefix='CB' Value='36' Function='SL-L' Group='Logical' Length='4'>
    <Encoding Preferred='true' Platform='z80'>
      <Mnemonic>SL1</Mnemonic>
      <Arguments>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>An arithmetic shift left 1-bit position is performed on the contents of operand m. The content of bit 7 is copied to the Carry flag. Bit 0 is set. Bit 0 is the least-significant bit.</Description>
    </Encoding>
    <Encoding Preferred='false' Platform='z80'>
      <Mnemonic>SLL</Mnemonic>
      <Arguments>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>SZ0P0C</Flags>
      <Description>An arithmetic shift left 1-bit position is performed on the contents of operand m. The content of bit 7 is copied to the Carry flag. Bit 0 is set. Bit 0 is the least-significant bit.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Prefix='CB' Value='38' Function='SR-L' Group='Logical' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>SRL</Mnemonic>
      <Arguments>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>0Z0P0C</Flags>
      <Description>The contents of operand m are shifted right 1-bit position. The content of bit 0 is copied to the Carry flag, and bit 7 is reset. Bit 0 is the least- significant bit. The result is stored in register r.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Prefix='CB' Value='3E' Function='SR-L' Group='Logical' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>SRL</Mnemonic>
      <Arguments>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>0Z0P0C</Flags>
      <Description>The contents of operand m are shifted right 1-bit position. The content of bit 0 is copied to the Carry flag, and bit 7 is reset. Bit 0 is the least- significant bit.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Prefix='CB' Value='40' Function='BIT' Group='Bit' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>BIT</Mnemonic>
      <Arguments>
        <Arg encoding='Dest'>Value</Arg>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>5(20)</Cycles>
      <Flags>?Z1?0-</Flags>
      <Description>This instruction tests bit b in the memory location specified by the contents of register pair IX combined with the two’s complement displacement d and sets the Z flag accordingly.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Prefix='CB' Value='46' Function='BIT' Group='Bit' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>BIT</Mnemonic>
      <Arguments>
        <Arg encoding='Dest'>Value</Arg>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>5(20)</Cycles>
      <Flags>?Z1?0-</Flags>
      <Description>This instruction tests bit b in the memory location specified by the contents of register pair IX combined with the two’s complement displacement d and sets the Z flag accordingly.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Prefix='CB' Value='80' Function='RES' Group='Bit' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>RES</Mnemonic>
      <Arguments>
        <Arg encoding='Dest'>Value</Arg>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>------</Flags>
      <Description>Bit b in operand m is reset, result is stored in register r.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Prefix='CB' Value='86' Function='RES' Group='Bit' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>RES</Mnemonic>
      <Arguments>
        <Arg encoding='Dest'>Value</Arg>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>------</Flags>
      <Description>Bit b in operand m is reset</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Prefix='CB' Value='C0' Function='SET' Group='Bit' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>SET</Mnemonic>
      <Arguments>
        <Arg encoding='Dest'>Value</Arg>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
        <Arg encoding='Source'>ByteReg</Arg>
      </Arguments>
      <Status>Undocumented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>------</Flags>
      <Description>Bit b in the memory location addressed by the sum of the contents of the IX register pair and the two’s complement integer d is set. Result is stored in register r.</Description>
    </Encoding>
  </Opcode>
  <Opcode Index='true' Prefix='CB' Value='C6' Function='SET' Group='Bit' Length='4'>
    <Encoding Platform='z80'>
      <Mnemonic>SET</Mnemonic>
      <Arguments>
        <Arg encoding='Dest'>Value</Arg>
        <Arg encoding='IndexOffset'>WordRegPtr-Iz</Arg>
      </Arguments>
      <Status>Documented</Status>
      <Cycles>6(23)</Cycles>
      <Flags>------</Flags>
      <Description>Bit b in the memory location addressed by the sum of the contents of the IX register pair and the two’s complement integer d is set. </Description>
    </Encoding>
  </Opcode>
</OpcodeData>
